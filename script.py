from statistics import stdev, mean
from psutil import Popen, cpu_count
from subprocess import PIPE
from threading import Thread, Lock
from random import randint
from shutil import copyfile

peersimLibraries = "../peersim-1.0.5/peersim-1.0.5.jar:../peersim-1.0.5/djep-1.0.0.jar:../peersim-1.0.5/jep-2.3.0.jar:../peersim-1.0.5/peersim-doclet.jar"
commonsmath35Library = "../commons-math3-3.5/commons-math3-3.5.jar"
bitTrustOutDir = "out/production/BitTrust"

libraries = peersimLibraries + ":" + commonsmath35Library + ":" + bitTrustOutDir

cfgFile = "conf/Time.conf"

simulation = 0
confidence = 0.95
zvalue = 1.96
min_interval_range = 0.05
mis = min_interval_range / 2  # Min interval spread
interval_spread = 1
interval_spread2 = 1

downtime = []
downtime2 = []


# Function to be run at each thread
def simulate(lock):
    """
    :param lock: Locker to
    :return: Nothing
    """

    global simulation, downtime, downtime2, interval_spread, interval_spread2
    while (simulation < 30) or (interval_spread > mis) or (interval_spread2 > mis):
        rand_seed = randint(0, 2**63-1)
        cfg_file2 = "conf/TimeTrust" + str(simulation) + ".conf"
        cfg_file3 = "conf/TimeNoTrust" + str(simulation) + ".conf"
        copyfile(cfgFile, cfg_file2)
        copyfile(cfgFile, cfg_file3)
        with open(cfg_file2, mode="a") as file:
            file.write("# This part was generated by the script\n")
            file.write("random.seed " + str(rand_seed) + "\n")
            file.write("protocol.simulation.unchoking trust")

        with open(cfg_file3, mode="a") as file:
            file.write("# This part was generated by the script\n")
            file.write("random.seed " + str(rand_seed) + "\n")
            file.write("protocol.simulation.unchoking original")

        p = Popen(["java", "-cp", libraries, "peersim.Simulator", cfg_file2], stdout=PIPE,
                  universal_newlines=True)
        p.wait()

        p2 = Popen(["java", "-cp", libraries, "peersim.Simulator", cfg_file3], stdout=PIPE,
                   universal_newlines=True)
        p2.wait()
        stdout = p.communicate()[0]
        # print(stdout)
        last_peer = stdout.split(" at time ")[-1]
        last_time = last_peer.split('\n')[0]
        # print(last_time)
        # last_time = 1900000

        stdout2 = p2.communicate()[0]
        # print(stdout)
        last_peer2 = stdout2.split(" at time ")[-1]
        last_time2 = last_peer2.split('\n')[0]
        # print(last_time)
        # last_time = 1900000
        try:
            lock.acquire(timeout=3)
            print("simulation" + str(simulation))
            ''' TODO if a thread locks here and confidence already at objective
            see a workaround'''
            simulation += 1
            # see and change confidence here
            downtime += [last_time]
            mean0 = mean(downtime)
            std0 = stdev(downtime)
            sqrt = len(downtime)**(1/2)
            error = zvalue*(std0/sqrt)
            # print(mean0, error, (mean0-error, mean0+error))
            interval_spread = (error / mean0)

            downtime2 += [last_time2]
            mean2 = mean(downtime2)
            std2 = stdev(downtime2)
            sqrt2 = len(downtime2)**(1/2)
            error2 = zvalue*(std2/sqrt2)
            # print(mean2, error2, (mean2-error2, mean2+error2))
            interval_spread2 = (error2 / mean2)

            print("simulation " + simulation + " has spread " + str(interval_spread) + " and " +
                  str(interval_spread2))

            lock.release()
        except TimeoutError:
            # p.kill()
            lock.release()

# def confidence_interval(data, confidence)

if __name__ == '__main__':
    nProcessors = cpu_count() - 1
    # nProcessors = 1

    t = []
    locker = Lock()

    # Create threads to control simulation
    for i in range(nProcessors):
        t.append(Thread(target=simulate, args=(locker,)))
        t[i].start()

    # Waits for threads to finish
    for i in range(nProcessors):
        t[i].join()

    print("done")
