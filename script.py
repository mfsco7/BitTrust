import csv
from datetime import datetime
from math import floor, ceil
from os import mkdir
from os.path import exists
from random import randint
from shutil import copyfile
from statistics import stdev, mean
from subprocess import PIPE
from threading import Thread, Lock

from matplotlib.pyplot import plot, savefig
from numpy import arange
from psutil import Popen, cpu_count

peersimLibraries = "../peersim-1.0.5/*"
commonsmath35Library = "../commons-math3-3.5/commons-math3-3.5.jar"
bitTrustOutDir = "out/production/BitTrust"

libraries = peersimLibraries + ":" + commonsmath35Library + ":" + bitTrustOutDir

cfgFile = "conf/Time.conf"

simulation = 0
confidence = 0.95
zvalue = 1.96
min_interval_range = 0.05
mis = min_interval_range / 2  # Min interval spread
interval_spread = 1
interval_spread2 = 1

downtime = []
downtime2 = []


def simulate(lock):
    """ Function that each thread will run. It will run one simulation with our trust algorithm
    and one with the original algorithm for at least 30 times and continues simulating while the
    interval spread is greater than the minimum interval spread.

    :param lock: Locker to ensure mutual exclusion
    :return: Nothing
    """

    global simulation, downtime, downtime2, interval_spread, interval_spread2
    while (simulation < 30) or (interval_spread > mis) or (interval_spread2 > mis):
        try:
            lock.acquire(timeout=3)
            sim = simulation
            print("simulation " + str(sim) + " starting")

            rand_seed = randint(1, 2 ** 63 - 1)
            cfg_file2 = generate_conf_file(rand_seed, sim, "trust")
            cfg_file3 = generate_conf_file(rand_seed, sim, "original")
            simulation += 1
            lock.release()

            last_time = run_process(cfg_file2)
            last_time2 = run_process(cfg_file3)

            lock.acquire(timeout=3)

            """ see and change confidence here """
            downtime += [last_time]
            downtime2 += [last_time2]
            if len(downtime) > 2:
                interval_spread = calc_interval(downtime)
                interval_spread2 = calc_interval(downtime2)

            with open('csv/simulationTimes.csv', 'a+', newline='') as csv_file2:
                writer2 = csv.writer(csv_file2, delimiter=';',
                                     quotechar='|', quoting=csv.QUOTE_MINIMAL)
                writer2.writerow([last_time, interval_spread, last_time2,
                                  interval_spread2])
            print("simulation " + str(sim) + " finishes")
            lock.release()
        except TimeoutError:
            lock.release()


def generate_conf_file(rand_seed=1234567890, sim=0, algorithm="trust"):
    """
    Make new configuration file based on template cfgFile. It will take a integer to
    be a random seed parameter and produce a file for passing to peersim simulator.

    :param rand_seed: Integer to be used as random seed
    :param sim: Simulation Number
    :param algorithm: Name of algorithm to be used. Can be 'trust' or 'original'
    :return: Names of Configuration files
    """
    cfg_file2 = "conf/Time" + algorithm + str(sim) + ".conf"
    copyfile(cfgFile, cfg_file2)
    with open(cfg_file2, mode="a") as file:
        file.write("# This part was generated by the script\n")
        file.write("random.seed " + str(rand_seed) + "\n")
        file.write("protocol.simulation.unchoking" + algorithm + "\n")

    return cfg_file2


def run_process(cfg_file="conf/Time-1.conf"):
    """
    Creates a new process and waits for it to end. After process termination it will fetch the
    last node download time.

    :param cfg_file: Name of configuration file
    :return: Time that last node took to fetch the file
    """
    p = Popen(["java", "-cp", libraries, "peersim.Simulator", cfg_file], stdout=PIPE, stderr=PIPE,
              universal_newlines=True)
    p.wait()

    stdout = p.communicate()[0]
    last_peer = stdout.split(" at time ")[-1]
    last_time = int(last_peer.split('\n')[0])

    return last_time


def calc_interval(down_time: list):
    """
    Computes the Interval Spread from the values contained on down_time. The interval spread is
    calculated by this formula: error / mean(values), with error as z-value * (stdev * sqrt(
    |values|)), z-value as 1.96 and stdev is standard deviation.

    :param down_time: All last downtime of all finished simulations
    :return: The Interval Spread
    """

    mean0 = mean(down_time)
    std0 = stdev(down_time)
    sqrt = len(down_time) ** (1 / 2)
    error = zvalue * (std0 / sqrt)
    # print(mean0, error, (mean0-error, mean0+error))
    return error / mean0


def calc_avg(num_group=100):
    """
    Calculates the average of downtime arrays. This method returns a smaller representation of
    points from two downtime arrays. It first splits each array, independently, in num_groups
    groups. Then it calculates for each group the average between the values. After this,
    this method joins and returns the values in the form of two arrays.

    :type num_group: int
    :param num_group: Maximum number of groups that will be created
    :return: Two arrays with the Averages of the two given downtime arrays
    """
    size = len(downtime)

    min_points = floor(size / num_group)
    max_points = ceil(size / num_group)

    n_cluster_max = size % num_group

    sim = 0
    x2, y2 = [], []
    cluster = n_cluster_max * [max_points] + (num_group - n_cluster_max) * [min_points]
    for nPoints in cluster:
        x2 += [sum(downtime[sim:sim + nPoints]) / nPoints]
        y2 += [sum(downtime2[sim:sim + nPoints]) / nPoints]
        sim += nPoints
    return x2, y2


def plot_graph(x: list, y: list):
    """
    Draw the graph from the downtimes and save it to a file

    :param x: Downtime of trust approach
    :param y: Downtime of original approach
    """
    plot(arange(len(x)), x, '.', arange(len(y)), y)
    time = datetime.now().strftime('%Y%m%d_%H%M%S')
    savefig("simulation_times_avg" + time + ".png")


if __name__ == '__main__':
    nProcessors = cpu_count() - 1
    # nProcessors = 1

    t = []
    locker = Lock()

    if not exists("csv"):
        mkdir("csv", 0o644)

    """ Creates new csv file or overwrites the old """
    with open('csv/simulationTimes.csv', 'w', newline='') as csv_file:
        writer = csv.writer(csv_file, delimiter=';',
                            quotechar='|', quoting=csv.QUOTE_MINIMAL)
        writer.writerow(['TrustTime', 'TrustSpread', 'NoTrustTime', 'NoTrustSpread'])

    """ Create threads to control simulation """
    for i in range(nProcessors):
        t.append(Thread(target=simulate, args=(locker,)))
        t[i].start()

    """ Waits for threads to finish """
    for i in range(nProcessors):
        t[i].join()

    avg_downtime, avg_downtime2 = calc_avg()
    plot_graph(avg_downtime, avg_downtime2)

    print("done")
