from random import randint
from shutil import copyfile
from statistics import stdev, mean
from subprocess import PIPE
from threading import Thread, Lock

from psutil import Popen, cpu_count

import csv

peersimLibraries = "../peersim-1.0.5/peersim-1.0.5.jar:../peersim-1.0.5/djep-1.0.0.jar:../peersim-1.0.5/jep-2.3.0.jar:../peersim-1.0.5/peersim-doclet.jar"
commonsmath35Library = "../commons-math3-3.5/commons-math3-3.5.jar"
bitTrustOutDir = "out/production/BitTrust"

libraries = peersimLibraries + ":" + commonsmath35Library + ":" + bitTrustOutDir

cfgFile = "conf/Time.conf"

simulation = 0
confidence = 0.95
zvalue = 1.96
min_interval_range = 0.05
mis = min_interval_range / 2  # Min interval spread
interval_spread = 1
interval_spread2 = 1

downtime = []
downtime2 = []


# Function to be run at each thread
def simulate(lock):
    """
    :param lock: Locker to
    :return: Nothing
    """

    global simulation, downtime, downtime2, interval_spread, interval_spread2
    while (simulation < 30) or (interval_spread > mis) or (interval_spread2 > mis):
        try:
            lock.acquire(timeout=3)
            simulation += 1
            cfg_file2, cfg_file3 = generate_conf_files()
            lock.release()
        except TimeoutError:
            lock.release()

        last_time = run_process(cfg_file2)
        last_time2 = run_process(cfg_file3)

        try:
            lock.acquire(timeout=3)
            print("simulation" + str(simulation))
            ''' TODO if a thread locks here and confidence already at objective
            see a workaround'''


            # see and change confidence here
            downtime += [last_time]
            downtime2 += [last_time2]
            if len(downtime) > 2:
                mean0 = mean(downtime)
                std0 = stdev(downtime)
                sqrt = len(downtime) ** (1 / 2)
                error = zvalue * (std0 / sqrt)
                # print(mean0, error, (mean0-error, mean0+error))
                interval_spread = (error / mean0)

                mean2 = mean(downtime2)
                std2 = stdev(downtime2)
                sqrt2 = len(downtime2) ** (1 / 2)
                error2 = zvalue * (std2 / sqrt2)
                # print(mean2, error2, (mean2-error2, mean2+error2))
                interval_spread2 = (error2 / mean2)

            print("simulation " + str(simulation) + " has spread " + str(interval_spread) + " and " +
                  str(interval_spread2))
            with open('csv/simulationTimes.csv', 'a+', newline='') as csv_file2:
                writer2 = csv.writer(csv_file2, delimiter=';',
                                    quotechar='|', quoting=csv.QUOTE_MINIMAL)
                writer2.writerow([simulation, last_time, interval_spread, last_time2,
                                  interval_spread2])

            lock.release()
        except TimeoutError:
            # p.kill()
            lock.release()


# def confidence_interval(data, confidence)
#


def generate_conf_files():
    """
    Generate configuration files

    :return: Names of Configuration files
    """
    rand_seed = randint(1, 2 ** 63 - 1)
    # rand_seed = 1234567890
    cfg_file2 = "conf/TimeTrust" + str(simulation) + ".conf"
    cfg_file3 = "conf/TimeNoTrust" + str(simulation) + ".conf"
    copyfile(cfgFile, cfg_file2)
    copyfile(cfgFile, cfg_file3)
    with open(cfg_file2, mode="a") as file:
        file.write("# This part was generated by the script\n")
        file.write("random.seed " + str(rand_seed) + "\n")
        file.write("protocol.simulation.unchoking trust\n")

    with open(cfg_file3, mode="a") as file2:
        file2.write("# This part was generated by the script\n")
        file2.write("random.seed " + str(rand_seed) + "\n")
        file2.write("protocol.simulation.unchoking original\n")

    return cfg_file2, cfg_file3


def run_process(cfg_file):
    """


    :param cfg_file: Name of configuration file
    :return: Time that last node took to fetch the file
    """
    p = Popen(["java", "-cp", libraries, "peersim.Simulator", cfg_file], stdout=PIPE, stderr=PIPE,
              universal_newlines=True)
    p.wait()

    stdout = p.communicate()[0]
    # print(stdout)
    last_peer = stdout.split(" at time ")[-1]
    last_time = int(last_peer.split('\n')[0])
    # print(last_time)
    # last_time = 1900000
    return last_time


if __name__ == '__main__':
    nProcessors = cpu_count() - 1
    # nProcessors = 1

    t = []
    locker = Lock()

    with open('csv/simulationTimes.csv', 'w', newline='') as csv_file:
        writer = csv.writer(csv_file, delimiter=';',
                            quotechar='|', quoting=csv.QUOTE_MINIMAL)
        writer.writerow(['SimNumber', 'TrustTime', 'TrustSpread', 'NoTrustSpread', 'NoTrustTime'])


    # Create threads to control simulation
    for i in range(nProcessors):
        t.append(Thread(target=simulate, args=(locker,)))
        t[i].start()

    # Waits for threads to finish
    for i in range(nProcessors):
        t[i].join()

    print("done")
